%%% \VignetteIndexEntry{Full matching in a study of coaching for the SAT: methodological update}
\documentclass{article}
\usepackage[round]{natbib}
\usepackage[left=1.25in,right=1in,top=1in,bottom=1in]{geometry}
\usepackage{longtable}
\usepackage{Sweave}
\title{Full matching in a study of coaching for the SAT (condensed treatment)}
\author{Ben Hansen}
\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle

This is a condensed, ever-so-slightly simplified session culminating
in a full match discussed and recommended in my paper ``Propensity score
matching to extract latent experiments from nonexperimental data: A
case study''  \citep{hansen2009b}.  The longer, unsimplfied session is
available in a similar format.  

The match this script leads to combines propensity and
prognostic scores in a way that I've found reliable and effective to
reduce bias while limiting the losses of sample size and precision
that can sometimes accompany matching-based analysis.

<<>>=
load("satcoach.RData")
###library(optmatch)
library(optmatch)
library(RItools)
library(xtable)
library(splines)
options(digits=3)
sessionInfo()
@ 

\section{Preliminaries to matching}


\subsection{the Race$\times$ SES subclassification}
The reasons to subclassify prior to matching are that large matching problems can take a lot of time, more time than several smaller matching problems taken together, at the same time that subclassifying is more intuitive than propensity score matching.

As noted by \citet{hansen:klopfer:2006}, the matching algorithm \texttt{optmatch} is based on uses roughly $O(n^{3}\log n)$ floating point operations, where $n$ is the sample size.  Comparing this estimate for the problem of matching without subclasses to that of matching withing Race$\times$ SES subclasses gives:
<<>>=
nrow(satcoach)
table(satcoach$ethn3levels, satcoach$dadsed)
matchflops <- function(n) n^3*log(n)
sum(matchflops(table(satcoach$ethn3levels, satcoach$dadsed)))/
matchflops(nrow(satcoach))
@ 

Preceding matching by the Race$\times$SES subclassification is the same as to match exactly (on propensity scores, Mahalanobis distances, prognostics scores or whatever) within Race$\times$ SES subclasses, which seems a sensible thing to do.

The Race $\times$ SES subclassification does improves balance, as the following calculations show.  Matching will bring more satisfying improvements to balance, however, as will be seen below.   Significance calculations here are permutation-based, as discussed in \citep{hansen:bowers:2008}.

<<>>=
xbs <- xtabs <- printtabs <- list()
xbs$sc.big <- 
  xBalance(Coach ~ 
           psatv + pmin(psatv,40) + pmax(psatv,60) + 
           psatm + pmin(psatm,40) + pmax(psatm,60) + 
           psat.NA + 
           presatv + pmin(presatv,400) + pmax(presatv,600) + 
           presatm + pmin(presatm,400) + pmax(presatm,600) + 
           presat.NA + 
           gpa + avgeng + 
           avgmath + avgnatsci + avgssci + nyrseng + nyrsfl + nyrsmath + 
           nyrsnatsci + nyrsssci+
           parentsincome + dadsed + momsed +
           full.1stlang  + gender + ethn3levels +
           Coll1mean + 
           Coll1mean.NA + 
           I23 + I24 + I25 + yearpref + deggoal + pubpripref, 
         strata=list(no.stratification=NULL, racebyses=~ethn3levels+dadsed), 
         data=satcoach, 
         report=c("adj.mean.diffs","chisquare.test"))
##xbs$sc.big$overall
xbs$sc.big
@ 
%(Just entering ``\texttt{xbs\$sc.big}'' would have returned the same
%information, but with a bit of extraneous accompanying printout.)

So the stratification helps, mostly, but observed balance is still far worse than it would have been under random assignment.

\subsection{Estimating the propensity score}

Here is an estimated propensity score. To somewhat relax the assumption of linearity of the propensity score in the 5 measurement variables, we expand each of them in natural splines.
<<>>=
ppty <- list()
ppty$fmla <- Coach ~ ns(psatv,df=4) + ns(psatm,df=4) + ns(presatv, df=4) + 
  ns(presatm, df=4) + ns(Coll1mean, df=4) + I23 + 
  I24 + I25 + parentsincome + dadsed + momsed + clpsed.ethn + 
  full.1stlang + yearpref + deggoal + pubpripref + gpa + avgeng + 
  avgmath + avgnatsci + avgssci + nyrseng + nyrsfl + nyrsmath + 
  nyrsnatsci + nyrsssci + gender + ethn3levels + 
  psat.NA + presat.NA + Coll1mean.NA
ppty$model <- glm(ppty$fmla, data=satcoach, family=binomial) 
ppty$score <- ppty$model$linear.predictors
all.equal(names(ppty$score), row.names(satcoach))
@ 

<<fig=TRUE,height=6,width=4,prefix.string=Pptyboxplot>>=
boxplot(ppty$model, names=c("Not Coached", "Coached"),
        ylab="Linear propensity scores", xlab="", varwidth = TRUE)
@ 

\section{Full matching on the propensity score}
\label{sec:full-match-prop}
To match within Race$\times$SES subclasses, we only need to calculate discrepancies on the propensity score (and/or on whatever else we may decided to match on) within these subclasses.  

First we create a block of possible matches.
<<>>=
ppty$blocks <- exactMatch(Coach ~ ethn3levels + dadsed,data=satcoach)
@ 
<<echo=FALSE>>=
numdmats1 <- length(levels(ppty$blocks@groups))
numentries1 <- sum(sapply(ppty$blocks,function(x) prod(dim(x))))
@ 
This incidentally reduces the burden of the problem on memory: matching within subclasses involves calculating and storing \Sexpr{numdmats1} distance matrices, with \Sexpr{signif(numentries1,3)} entries in total, whereas matching without subclasses requires us to store and calculate one large \Sexpr{with(satcoach, sum(as.logical(Coach)))} $\times$ \Sexpr{with(satcoach, sum(!Coach))} matrix, with \Sexpr{signif(with(satcoach, prod(table(Coach))),3)} entries.

\subsection{Propensity score full matching}

Plain-vanilla full matching on the propensity score (within Race$\times$SES subclasses).
<<>>=
#fm.ppty <- fullmatch(ppty$model, within=ppty$blocks, data=satcoach)
#will replace following 2 lines
ppty$dist<-match_on(ppty$model, within=ppty$blocks, data=satcoach)
fm.ppty<-fullmatch(ppty$dist,data=satcoach)
summary(fm.ppty,ppty$model) 
stratumStructure(fm.ppty, min.controls=0.2, max.controls=5)
@ 

Balance looks good, but there are outliers in terms of matched distances on the propensity score.  This is something to avoid \citep{hansen2009}.  Calipers are the natural remedy:
<<>>=
#fm.ppty.clpr050 <- fullmatch(ppty$model, within=ppty$dist, data=satcoach, caliper=0.5)
ppty$dist.clpr050 <-match_on(ppty$model, within=ppty$blocks, caliper=0.5, data=satcoach)
fm.ppty.clpr050 <- fullmatch(ppty$dist.clpr050, data=satcoach)
summary(fm.ppty.clpr050,ppty$model)
stratumStructure(fm.ppty.clpr050,min.controls=0.2, max.controls=5)
@ 
Note that the addition of this caliper has caused some treatment group
members to go unmatched --- these are the ``1:0'' matched sets noted
in the summary.  (\texttt{fullmatch(<\ldots>)} and \texttt{pairmatch(<\ldots>,
  remove.unmatchables=T)} automatically remove subjects without permissible matches before they begin to match.  That's what's happened to these treatment group members, as well as to the controls falling in 0:1 ``matched sets.'')  


\section{Full matching with prognostic and propensity scores}
\label{sec:full-matching-with-pg}
Here's another way to manage the tradeoff between bias reduction and effective sample size, one that can be operationally simpler and might offer some additional bias protection as well: matching one propensity score within calipers of another, constructing the first propensity score in such a way as to keep to a minimum separation between coached and uncoached kids while constructing the second in such a way as to promote balance on as many covariates as possible.  A natural way to get less-separation propensity scores is to permit in them only covariates or functions of the covariate that are most predictive of the response.


\subsection{A focused propensity score}

Extracting summaries of the part of the covariate other than pretests,
as it relates to pretest score.  Because these summaries are
inherently one-dimensional, because OLS is not necessarily the best
approach, and because we're skipping any diagnostics, they are
potentially rather crude.  I have set to `NA' early SAT scores or PSAT
scores from test sittings after a student was coached, as well as
prior test scores of uncoached students from sittings close in time to
their sitting for the posttest, as discussed in
\citep[\S~1.2]{hansen:2004}.  This helps to ensure that the pretest
genuinely anteceded the treatment, and improves motivation of models
in which assignment to treatment occurs strictly after (what we are
considering to be) pretests.

<<>>=

pg.mod <- list()
(pg.mod$m.fmla <- update.formula(ppty$fmla, postsatmath~.-ethn3levels))
(pg.mod$v.fmla <- update.formula(ppty$fmla, postsatverb~.-ethn3levels))
###pg.mod$basicfmla <-  ~ Coll1mean + I23 + 
###  I24 + I25 + parentsincome + dadsed + momsed + clpsed.ethn + 
###  full.1stlang + yearpref + deggoal + pubpripref + gpa + avgeng + 
###  avgmath + avgnatsci + avgssci + nyrseng + nyrsfl + nyrsmath + 
###  nyrsnatsci + nyrsssci + gender + Coll1mean.NA

pg.mod$v <- 
 lm(pg.mod$v.fmla, #update.formula(pg.mod$basicfmla, psatv~.), 
    data=satcoach, subset=!Coach#!psat.NA
    )
pg.mod$m <- 
 lm(pg.mod$m.fmla, #update.formula(pg.mod$basicfmla, psatm~.), 
    data=satcoach, subset=!Coach#!psat.NA
    )
pg.mod$scorenames <- 
  c('psatv', 'psatm', 'presatv', 'presatm', 'psat.NA', 'presat.NA')
pg.mod$scores <- 
  data.frame(satcoach[c('Coach', pg.mod$scorenames)], 
             pg.v=predict(pg.mod$v, satcoach),
             pg.m=predict(pg.mod$m, satcoach),
             check.rows=T)
pg.ppty <- list()
pg.ppty$fmla <- Coach ~ psatv + psatm + presatv + presatm + 
  psat.NA + presat.NA + pg.v + pg.m
(pg.ppty$model <- 
 glm(pg.ppty$fmla, 
     data=pg.mod$scores, family=binomial) )
@ 

Here's how the ordinary propensity and the prognostic propensity differ in terms of how they separate treatment and control groups.

<<fig=TRUE,height=6,width=8,prefix.string=Pptyboxplots>>=
pg.ppty$score <- pg.ppty$model$linear.predictor 
all.equal(names(pg.ppty$score), row.names(satcoach))
par(mfrow=c(1,2))
boxplot(ppty$model, names=c("Not coached", "Coached"), 
ylab="Ordinary propensity scores", xlab="", varwidth = TRUE, ylim=range(ppty$score))
boxplot(pg.ppty$model, names=c("Not coached", "Coached"), 
        ylab="Focused propensity scores", xlab="", varwidth = TRUE, 
        ylim=range(ppty$score))
par(mfrow=c(1,1))
lm1 <- lm(ppty$score~Coach, data=satcoach)
(ppty$meansep <- coef(lm1)['Coach']/sqrt(mean(residuals(lm1)^2)))
lm1 <- lm(pg.ppty$score~Coach, data=satcoach)
(pg.ppty$meansep <- coef(lm1)['Coach']/sqrt(mean(residuals(lm1)^2)))
rm(lm1)
@ 

\subsection{Full matching on propensity and prognostic propensity scores}

Distance on the prognostic score (to begin with, without calipers).  Note the complaint from the distance-making functions about the stratifying variables not being in the propensity specification.  Given that they are included in the ordinary propensity score, and we'll be putting in a caliper on that, it's nothing to worry about.
<<>>=
pg.ppty$blocks <- exactMatch(Coach ~ ethn3levels + dadsed, data=satcoach)
pg.ppty$dist <- match_on(pg.ppty$model, within=pg.ppty$blocks, data=satcoach)
pg.ppty$dist.with.ppty.calipers <- caliper(pg.ppty$dist, width=0.5)
fm.pgppty.pptyclpr <- fullmatch(pg.ppty$dist.with.ppty.calipers,data=satcoach)
#fm.pgppty.pptyclpr <- fullmatch(pg.ppty$model, within=pg.ppty$blocks, data=satcoach, caliper=0.5)
#previous will replace pg.ppty$dist and pg.ppty$dist.with.ppty.calipers and fm.pgppty.pptyclpr

@ 



\subsection{Assessing the match}

Summary, including summary of balance on all variables contributing to
the (ordinary) propensity score.

<<>>=

summary(fm.pgppty.pptyclpr, ppty$model)
stratumStructure(fm.pgppty.pptyclpr,min.controls=0.2,max.controls=5)
@ 

Plot of balance on variables contributing to focused/prognostic
propensity score.
<<fig=TRUE,prefix.string=smallloveplot>>=

(xb <- 
 xBalance(Coach ~ pg.v + pg.m + psat.NA + psatv + psatm + 
          presat.NA + presatv + presatm, 
          strata=list(racebySES=
            ~interaction(satcoach$dadsed,satcoach$ethn3levels), 
            matched=~fm.pgppty.pptyclpr),
         report=c("std.diffs", "p.values", "chisquare.test"),
         data=pg.mod$scores)
 )
plot(xb, legend=FALSE, 
     thexlab="(Adjusted coached minus uncoached difference)/(pooled sd)")
legend(x='topright', 
       legend=c("initial subclassification",
         "focused PS w/ PS calipers"), 
       col=rainbow(3), pch=c(19,22,23), bty='n' )

@ 


\section{Outcome Analysis}

\subsection{Matched permutation tests without covariance adjustment}

Here is a formula that will be used to adjust the outcome vector for various hypothesized treatment effects.
<<>>=
verbfmla <- 
paste("Coach ~", paste(paste("I(postsatverb -", -15:35, "*Coach)"), collapse="+"))
verbfmla <- as.formula(verbfmla)
@ 

$p$-values, a Hodges-Lehmann point estimate and confidence intervals.
<<>>=
pvals.verb <- xBalance(verbfmla,strata=fm.pgppty.pptyclpr, data=satcoach,
                  report=c("p.values"))$results[,'p',1]
names(pvals.verb) <- -15:35
(-15:35)[pvals.verb==max(pvals.verb)]
range((-15:35)[pvals.verb>=.05])
@ 

Similarly for math effects:

<<>>=
mathfmla <- 
paste("Coach ~", paste(paste("I(postsatmath -", -5:45, "*Coach)"), collapse="+"))
mathfmla <- as.formula(mathfmla)
pvals.math <- xBalance(mathfmla,strata=fm.pgppty.pptyclpr, data=satcoach,
                  report=c("p.values"))$results[,'p',1]
names(pvals.math) <- -5:45
(-5:45)[pvals.math==max(pvals.math)]
range((-5:45)[pvals.math>=.05])

@ 

\subsection{Matched permutation tests with Rosenbaum-type covariance adjustment}

Here is a data frame consisting of sat-verbal responses adjusted, first, for one of 51 hypothesised treatment effects; and, second, adjusted for covariance with pretests.  From the perspective of any of the 51 null hypotheses, after the two adjustments residuals ought to be permutable within matched sets, and a permutation test is appropriate.  The \texttt{RItools} function \texttt{xBalance()} is used to provide Normal approximations to these permutation tests.

Because we first introduce offsets for hypothesized treatment effects and then perform covariance adjustment, on the entire data set, I call this \citet{rosenbaum:2002a} type covariance adjustment. 
<<>>=

fmla.lhs <- ~ psatv + psatm +psat.NA + presatv + presatm + presat.NA #+ 
#fm.pgppty.pptyclpr

adj.vresp <- 
lapply(-15:35, function(tau) {
fmla <- as.formula(paste("I(postsatverb -", tau, "*Coach)~.", collapse=""))
fmla <- update.formula(fmla.lhs, 
                       fmla)
residuals(lm(fmla, data=satcoach))
})
adj.vresp <- as.data.frame(adj.vresp)
names(adj.vresp) <- paste('e', 1:length(adj.vresp), sep="")
@ 

Now to compute and extract the confidence interval.
<<>>=
xbfmla.rhs <- paste('e', 1:length(adj.vresp), sep="")
xbfmla.rhs <- as.formula(paste("~", paste(xbfmla.rhs, collapse="+")))

adj.vresp$Coach <- satcoach$Coach#[matched(fm.pgppty.pptyclpr)]
pvals.verb <- 
  xBalance(update.formula(xbfmla.rhs, Coach ~.),
           strata=fm.pgppty.pptyclpr,#[matched(fm.pgppty.pptyclpr)], 
           data=adj.vresp,
                  report=c("p.values"))$results[,'p',1]
names(pvals.verb) <- -15:35
(-15:35)[pvals.verb==max(pvals.verb)]
range((-15:35)[pvals.verb>=.05])

@ 


Now to do the same for math.
<<>>=
adj.mresp <- 
lapply(-5:45, function(tau) {
fmla <- as.formula(paste("I(postsatmath -", tau, "*Coach)~.", collapse=""))
fmla <- update.formula(fmla.lhs, 
                       fmla)
residuals(lm(fmla, data=satcoach))
})
adj.mresp <- as.data.frame(adj.mresp)
names(adj.mresp) <- paste('e', 1:length(adj.mresp), sep="")
adj.mresp$Coach <- satcoach$Coach#[matched(fm.pgppty.pptyclpr)]

pvals.math <- 
  xBalance(update.formula(xbfmla.rhs, Coach ~.),
           strata=fm.pgppty.pptyclpr,#[matched(fm.pgppty.pptyclpr)], 
           data=adj.mresp,
                  report=c("p.values"))$results[,'p',1]
names(pvals.math) <- -5:45
(-5:45)[pvals.math==max(pvals.math)]
range((-5:45)[pvals.math>=.05])

@ 


\bibliographystyle{asa}
\bibliography{abbrev_long,biomedicalapplications,causalinference,misc,computing}


\end{document}
